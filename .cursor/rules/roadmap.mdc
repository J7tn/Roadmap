# Career Atlas Development Rules

You are an expert in React, TypeScript, and scalable web application development for career roadmap applications.

## Critical Rules (Always Follow)

1. **Don't use deprecated or obsolete APIs.** Always use the latest React, TypeScript, and library APIs. Replace deprecated methods immediately when found.
2. **Always write down component names/interface names** so that new components don't re-use names that are already in use.
3. **Always organize code into logical modules** to make development faster and improve maintainability.
4. **Always hide sensitive information** by updating environment variables and .gitignore to prevent committing any sensitive data.
5. **Always use a phased initialization system** for data loading and component mounting to prevent dependency errors.
6. **Always use the latest React patterns** - prefer hooks over class components, use modern state management patterns.
7. **Always ensure proper type safety** - use TypeScript interfaces and types consistently throughout the application.
8. **ALWAYS design for mobile-first** - All UI components, layouts, and interactions must be optimized for Google/Android devices first, then adapted for desktop.

## Mobile-First Design Rules (Google/Android Optimization)

* **Touch-Friendly Interface**: All interactive elements must have minimum 44px touch targets for easy finger navigation
* **Mobile Navigation**: Use slide-out menus, bottom navigation, or hamburger menus for mobile navigation
* **Responsive Typography**: Use scalable font sizes that work well on small screens (12px minimum, 16px preferred for body text)
* **Mobile-Optimized Cards**: Design cards with proper spacing, touch-friendly buttons, and readable text on small screens
* **Gesture Support**: Implement swipe gestures, pull-to-refresh, and other mobile-friendly interactions
* **Viewport Optimization**: Ensure all content fits properly within mobile viewports (320px-428px width range)
* **Loading States**: Use skeleton screens and loading indicators optimized for mobile screens
* **Form Design**: Design forms with large input fields, clear labels, and mobile-friendly validation
* **Image Optimization**: Use responsive images and lazy loading for mobile performance
* **Mobile Testing**: Always test on Android devices/emulators to ensure proper functionality
* **Progressive Enhancement**: Start with mobile design, then enhance for larger screens
* **Accessibility**: Ensure all mobile interactions are accessible (proper contrast, screen reader support)

## Key Principles

* Write clear, technical responses with precise React and TypeScript examples.
* Use React's built-in features and hooks wherever possible to leverage its full capabilities.
* Prioritize readability and maintainability; follow React coding conventions and TypeScript best practices.
* Use descriptive variable and function names; adhere to naming conventions (e.g., PascalCase for components, camelCase for variables).
* Structure your project in a modular way using React's component-based architecture to promote reusability and separation of concerns.
* **Mobile-first approach**: Design and develop for mobile devices first, then scale up for desktop.

## React/TypeScript Guidelines

* Use functional components with hooks for all new components; prefer custom hooks for reusable logic.
* Leverage React's state management patterns (useState, useContext, useReducer) appropriately for different use cases.
* Use TypeScript interfaces for all props, state, and API responses to ensure type safety.
* Utilize React Router for navigation and routing across the application.
* Follow the Component pattern strictly for clear separation of concerns and modularity.
* Use React.memo and useMemo for performance optimization when appropriate.
* **Mobile-responsive components**: Use Tailwind's responsive classes (sm:, md:, lg:) to create mobile-first layouts.

## Error Handling and Debugging

* Implement error boundaries for React components to catch and handle errors gracefully.
* Use proper error handling for API calls with try-catch blocks and error states.
* Utilize React DevTools and browser developer tools for debugging component state and props.
* Implement custom error messages and loading states to improve user experience.
* Use TypeScript's strict mode to catch type errors during development.
* **Mobile error handling**: Ensure error messages are readable on small screens and provide clear next steps.

## Dependencies

* React 18+ with hooks
* TypeScript 5+
* Vite for build tooling
* Tailwind CSS for styling
* Radix UI for accessible components
* Framer Motion for animations
* React Router for navigation
* Supabase for backend services
* **Capacitor for mobile deployment** to Google Play Store

## React-Specific Guidelines

* Use JSX for component templates and keep them readable and well-structured.
* Keep components focused on a single responsibility; split large components into smaller ones.
* Utilize React's lifecycle methods and hooks appropriately (useEffect, useLayoutEffect, etc.).
* Apply proper prop drilling prevention using Context API or state management libraries.
* Use React's built-in testing utilities (React Testing Library) for component testing.
* Leverage React's Suspense and lazy loading for code splitting and performance optimization.
* Use React's key prop correctly for list rendering to optimize re-renders.
* **Mobile component patterns**: Use mobile-friendly patterns like infinite scroll, virtual lists, and touch gestures.

## Performance Optimization

* Use React.memo for components that receive the same props frequently.
* Implement useMemo and useCallback for expensive calculations and function references.
* Optimize re-renders by properly structuring component hierarchies and state.
* Use code splitting with React.lazy and Suspense for route-based splitting.
* Implement virtual scrolling for large lists using libraries like react-window.
* Optimize bundle size by analyzing and removing unused dependencies.
* **Mobile performance**: Optimize for mobile networks, reduce bundle size, and implement progressive loading.

## Code Organization Rules

**Component Structure**: Create separate folders for different types of components (pages, features, shared, ui)
**Interface Definitions**: Always define TypeScript interfaces in separate files or at the top of component files
**File Organization**: Keep related components together in logical folders
**Documentation**: Add JSDoc comments to complex functions and components
**Naming Conventions**:
  * Components: PascalCase (e.g., `CareerRoadmap.tsx`)
  * Files: PascalCase for components, camelCase for utilities (e.g., `careerUtils.ts`)
  * Folders: kebab-case (e.g., `career-roadmap/`)
  * Interfaces: PascalCase with 'I' prefix (e.g., `ICareerNode`)
**Mobile Components**: Use descriptive names that indicate mobile optimization (e.g., `MobileNavigation.tsx`, `TouchFriendlyButton.tsx`)

## Data Management Rules

* **Phased Data Loading**: All data fetching must use a phased loading system to prevent dependency errors.
* **Loading States**: Always implement proper loading states for async operations.
* **Error States**: Handle error states gracefully with user-friendly messages.
* **Caching Strategy**: Implement appropriate caching for API responses using React Query or similar.
* **State Validation**: Always validate data before updating state.
* **Type Safety**: Use TypeScript interfaces for all API responses and state objects.
* **Error Boundaries**: Implement error boundaries for data fetching components.
* **Mobile Data**: Optimize data loading for mobile networks with proper caching and offline support.

## Component Design Rules

* Keep components small - one main responsibility only.
* Use clear props interfaces, avoid complex prop drilling.
* If a component is more than 200-300 lines, consider splitting it.
* Use early returns for conditional rendering to avoid deeply nested JSX.
* Prefer composition over inheritance for component reuse.
* **Mobile component design**: Design components with touch interactions, proper spacing, and mobile-friendly layouts.

## API Usage Rules

* **Never use deprecated React APIs**: Always check for and use the latest React patterns.
* **Replace deprecated methods immediately**: When React marks an API as obsolete, update all usages.
* **Use modern hooks**: Prefer hooks over class components and lifecycle methods.
* **Implement proper error handling**: Always handle API errors and loading states.
* **Check React documentation regularly**: Stay updated with the latest React patterns.
* **Test with latest React versions**: Ensure compatibility with current React releases.
* **Mobile API optimization**: Use mobile-optimized API calls with proper caching and offline support.

## Project Structure Guidelines

* **Modular Architecture**: Organize code into logical modules (components, hooks, utils, types, etc.).
* **Clear Separation of Concerns**: Each module should have a specific responsibility.
* **Scalable Design**: Structure should support project growth and feature additions.
* **Consistent Naming**: Use consistent naming conventions across the entire project.
* **Documentation**: Maintain up-to-date documentation for all major components and features.
* **Mobile-first structure**: Organize components with mobile considerations in mind.

## Version Control Best Practices

* **Meaningful Commits**: Write clear, descriptive commit messages.
* **Feature Branches**: Use feature branches for new development.
* **Code Review**: Review code before merging to main branch.
* **Asset Management**: Use .gitignore to exclude generated files and sensitive data.
* **Backup Strategy**: Regular backups of project files and assets.

## Testing and Quality Assurance

* **Unit Testing**: Write unit tests for critical business logic and utilities.
* **Component Testing**: Test React components using React Testing Library.
* **Integration Testing**: Test component interactions and data flow.
* **Performance Testing**: Monitor bundle size and component render performance.
* **Accessibility Testing**: Ensure components meet WCAG guidelines.
* **Cross-browser Testing**: Test on target browsers regularly.
* **Mobile Testing**: Test on Android devices and emulators to ensure mobile compatibility.

## Career Roadmap Specific Rules

* **Data Structure**: Use consistent interfaces for career nodes, paths, and categories as defined in `docs/DESIGN.md`.
* **Visualization**: Implement responsive and accessible career path visualizations following the design specifications.
* **User Experience**: Focus on intuitive navigation and clear information hierarchy as outlined in the design document.
* **Performance**: Optimize for large datasets of career information with proper caching and pagination.
* **Accessibility**: Ensure career roadmaps are accessible to users with disabilities (WCAG 2.1 AA compliance).
* **Internationalization**: Plan for multi-language support in career content.
* **Design Reference**: Always refer to `docs/DESIGN.md` for feature specifications, data models, and implementation guidelines.
* **Mobile Career Experience**: Design career roadmaps to be easily navigable on mobile devices with touch-friendly interactions.

## Build and Deployment Rules

* **Always Build and Run After Major Updates**: After implementing significant features, UI changes, or adding new pages/components, ALWAYS run the complete build and deployment process:
  1. `npm run build` - Build the web assets
  2. `npx cap sync` - Sync with Android project  
  3. `npx cap open android` - Open in Android Studio for testing
* **Android Testing**: Test all major changes on Android device/emulator to ensure mobile compatibility
* **Cross-Platform Validation**: Verify that web and mobile versions work consistently
* **Performance Monitoring**: Check bundle size and loading performance after major updates
* **Mobile Deployment**: Ensure the app is ready for Google Play Store deployment

## Key Conventions

1. Follow React's component-based architecture for modular and reusable UI elements.
2. Prioritize performance optimization and bundle size management in every stage of development.
3. Maintain a clear and logical project structure to enhance readability and asset management.
4. Use TypeScript for type safety and better developer experience.
5. Document all major components with JSDoc comments.
6. Use a phased data loading system for all async operations to prevent dependency issues.
7. Implement proper error handling and loading states in all components.
8. Always use the latest React patterns and avoid deprecated methods.
9. Ensure proper type safety when using external APIs and data.
10. Follow consistent naming conventions and coding standards throughout the project.
11. **ALWAYS build and run on Android after major updates** - This ensures mobile compatibility and catches platform-specific issues early.
12. **Design mobile-first** - All UI components must be optimized for Google/Android devices with touch-friendly interfaces.

Refer to React documentation, TypeScript guides, and modern web development best practices for optimal application architecture, component design, and performance optimization.
alwaysApply: true
---
