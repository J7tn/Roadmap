# Career Atlas Development Rules

You are an expert in React, TypeScript, and scalable web application development for career roadmap applications.

## Critical Rules (Always Follow)

1. **Don't use deprecated or obsolete APIs.** Always use the latest React, TypeScript, and library APIs. Replace deprecated methods immediately when found.
2. **Always write down component names/interface names** so that new components don't re-use names that are already in use.
3. **Always organize code into logical modules** to make development faster and improve maintainability.
4. **Always hide sensitive information** by updating environment variables and .gitignore to prevent committing any sensitive data.
5. **ALWAYS use VITE_ prefixed environment variables** - This project uses Vite, not Create React App, so all environment variables must use the `VITE_` prefix (e.g., `VITE_SUPABASE_URL`, `VITE_SUPABASE_ANON_KEY`, `VITE_CHAT2API_URL`). Never use `REACT_APP_` prefixed variables.
6. **Always use a phased initialization system** for data loading and component mounting to prevent dependency errors.
7. **Always use the latest React patterns** - prefer hooks over class components, use modern state management patterns.
8. **Always ensure proper type safety** - use TypeScript interfaces and types consistently throughout the application.
9. **ALWAYS design for mobile-first** - All UI components, layouts, and interactions must be optimized for Google/Android devices first, then adapted for desktop.
10. **ALWAYS ensure Google device compatibility** - The app must run on all Google devices including newer devices with latest Android APIs. Support Android API 22+ (Android 5.1) through API 34+ (Android 14+). Test on both older and newer Google devices to ensure compatibility across the entire Android ecosystem.

## Mobile-First Design Rules (Google/Android Optimization)

* **Touch-Friendly Interface**: All interactive elements must have minimum 44px touch targets for easy finger navigation
* **Mobile Navigation**: Use slide-out menus, bottom navigation, or hamburger menus for mobile navigation
* **Responsive Typography**: Use scalable font sizes that work well on small screens (12px minimum, 16px preferred for body text)
* **Mobile-Optimized Cards**: Design cards with proper spacing, touch-friendly buttons, and readable text on small screens
* **Gesture Support**: Implement swipe gestures, pull-to-refresh, and other mobile-friendly interactions
* **Viewport Optimization**: Ensure all content fits properly within mobile viewports (320px-428px width range)
* **Loading States**: Use skeleton screens and loading indicators optimized for mobile screens
* **Form Design**: Design forms with large input fields, clear labels, and mobile-friendly validation
* **Image Optimization**: Use responsive images and lazy loading for mobile performance
* **Mobile Testing**: Always test on Android devices/emulators to ensure proper functionality
* **Progressive Enhancement**: Start with mobile design, then enhance for larger screens
* **Accessibility**: Ensure all mobile interactions are accessible (proper contrast, screen reader support)

## Key Principles

* Write clear, technical responses with precise React and TypeScript examples.
* Use React's built-in features and hooks wherever possible to leverage its full capabilities.
* Prioritize readability and maintainability; follow React coding conventions and TypeScript best practices.
* Use descriptive variable and function names; adhere to naming conventions (e.g., PascalCase for components, camelCase for variables).
* Structure your project in a modular way using React's component-based architecture to promote reusability and separation of concerns.
* **Mobile-first approach**: Design and develop for mobile devices first, then scale up for desktop.

## React/TypeScript Guidelines

* Use functional components with hooks for all new components; prefer custom hooks for reusable logic.
* Leverage React's state management patterns (useState, useContext, useReducer) appropriately for different use cases.
* Use TypeScript interfaces for all props, state, and API responses to ensure type safety.
* Utilize React Router for navigation and routing across the application.
* Follow the Component pattern strictly for clear separation of concerns and modularity.
* Use React.memo and useMemo for performance optimization when appropriate.
* **Mobile-responsive components**: Use Tailwind's responsive classes (sm:, md:, lg:) to create mobile-first layouts.

## Error Handling and Debugging

* Implement error boundaries for React components to catch and handle errors gracefully.
* Use proper error handling for API calls with try-catch blocks and error states.
* Utilize React DevTools and browser developer tools for debugging component state and props.
* Implement custom error messages and loading states to improve user experience.
* Use TypeScript's strict mode to catch type errors during development.
* **Mobile error handling**: Ensure error messages are readable on small screens and provide clear next steps.

## Dependencies

* React 18+ with hooks
* TypeScript 5+
* Vite for build tooling
* Tailwind CSS for styling
* Radix UI for accessible components
* Framer Motion for animations
* React Router for navigation
* Supabase for backend services
* **Capacitor for mobile deployment** to Google Play Store

## React-Specific Guidelines

* Use JSX for component templates and keep them readable and well-structured.
* Keep components focused on a single responsibility; split large components into smaller ones.
* Utilize React's lifecycle methods and hooks appropriately (useEffect, useLayoutEffect, etc.).
* Apply proper prop drilling prevention using Context API or state management libraries.
* Use React's built-in testing utilities (React Testing Library) for component testing.
* Leverage React's Suspense and lazy loading for code splitting and performance optimization.
* Use React's key prop correctly for list rendering to optimize re-renders.
* **Mobile component patterns**: Use mobile-friendly patterns like infinite scroll, virtual lists, and touch gestures.

## Performance Optimization

* Use React.memo for components that receive the same props frequently.
* Implement useMemo and useCallback for expensive calculations and function references.
* Optimize re-renders by properly structuring component hierarchies and state.
* Use code splitting with React.lazy and Suspense for route-based splitting.
* Implement virtual scrolling for large lists using libraries like react-window.
* Optimize bundle size by analyzing and removing unused dependencies.
* **Mobile performance**: Optimize for mobile networks, reduce bundle size, and implement progressive loading.

## Code Organization Rules

**Component Structure**: Create separate folders for different types of components (pages, features, shared, ui)
**Interface Definitions**: Always define TypeScript interfaces in separate files or at the top of component files
**File Organization**: Keep related components together in logical folders
**Documentation**: Add JSDoc comments to complex functions and components
**Naming Conventions**:
  * Components: PascalCase (e.g., `CareerRoadmap.tsx`)
  * Files: PascalCase for components, camelCase for utilities (e.g., `careerUtils.ts`)
  * Folders: kebab-case (e.g., `career-roadmap/`)
  * Interfaces: PascalCase with 'I' prefix (e.g., `ICareerNode`)
**Mobile Components**: Use descriptive names that indicate mobile optimization (e.g., `MobileNavigation.tsx`, `TouchFriendlyButton.tsx`)

## Data Management Rules

* **Phased Data Loading**: All data fetching must use a phased loading system to prevent dependency errors.
* **Loading States**: Always implement proper loading states for async operations.
* **Error States**: Handle error states gracefully with user-friendly messages.
* **Caching Strategy**: Implement appropriate caching for API responses using React Query or similar.
* **State Validation**: Always validate data before updating state.
* **Type Safety**: Use TypeScript interfaces for all API responses and state objects.
* **Error Boundaries**: Implement error boundaries for data fetching components.
* **Mobile Data**: Optimize data loading for mobile networks with proper caching and offline support.

## Component Design Rules

* Keep components small - one main responsibility only.
* Use clear props interfaces, avoid complex prop drilling.
* If a component is more than 200-300 lines, consider splitting it.
* Use early returns for conditional rendering to avoid deeply nested JSX.
* Prefer composition over inheritance for component reuse.
* **Mobile component design**: Design components with touch interactions, proper spacing, and mobile-friendly layouts.

## Reusable Components Rule (CRITICAL)

**ALWAYS create reusable components when the same UI pattern or functionality appears in multiple places.** This is a fundamental principle for maintaining code quality and consistency.

### When to Create Reusable Components:
* **Repeated UI Patterns**: Page headers, search inputs, loading states, error states, empty states
* **Common Functionality**: Navigation elements, buttons, cards, forms, modals
* **Repeated Code Blocks**: Any code that appears 2+ times across different files
* **Similar Logic**: Data fetching patterns, state management, validation functions

### Reusable Component Requirements:
* **Single Responsibility**: Each component should do one thing well
* **Configurable Props**: Use props to make components flexible and customizable
* **TypeScript Interfaces**: Define clear prop interfaces with proper types
* **Default Values**: Provide sensible defaults for optional props
* **Consistent Styling**: Use the same design system and styling patterns
* **Mobile-First**: All reusable components must be mobile-optimized

### Implementation Guidelines:
* **Extract Early**: Don't wait for 3+ repetitions - extract after 2 occurrences
* **Make It Flexible**: Use props for customization rather than hardcoded values
* **Document Usage**: Add JSDoc comments explaining component purpose and props
* **Test in Isolation**: Ensure components work independently
* **Follow Naming**: Use descriptive names (e.g., `PageHeader`, `SearchInput`, `LoadingSpinner`)

### Examples of Reusable Components:
* `PageHeader` - Back button + icon + title + optional badge
* `SearchInput` - Search icon + input + suggestions + filter button
* `LoadingSpinner` - Animated spinner with customizable message and size
* `ErrorState` - Error icon + message + retry button
* `EmptyState` - Icon + title + description + optional action button
* `BottomNavigation` - Consistent navigation across all pages

### Benefits:
* **Code Reduction**: Eliminates duplicate code (50%+ reduction in codebase size)
* **Consistency**: Same look and behavior across all pages
* **Maintainability**: Fix once, applies everywhere
* **Development Speed**: New pages get common UI automatically
* **Type Safety**: Better TypeScript support and error catching

## State Management Rules (CRITICAL)

**ALWAYS follow consistent state management patterns to prevent bugs and improve maintainability.**

### State Management Guidelines:
* **Custom Hooks for Complex State**: Extract complex state logic into custom hooks (e.g., `useBookmarks`, `useCareerData`)
* **Single Source of Truth**: Each piece of data should have one authoritative source
* **Immutable Updates**: Always use immutable patterns for state updates (spread operator, functional updates)
* **State Validation**: Validate data before updating state, especially for user inputs
* **Loading States**: Always implement loading states for async operations
* **Error Boundaries**: Wrap components with error boundaries for graceful error handling

### State Structure Rules:
* **Group Related State**: Keep related state together in objects rather than separate useState calls
* **Derived State**: Use useMemo for expensive calculations, useCallback for stable function references
* **State Lifting**: Lift state up to the lowest common ancestor that needs it
* **Avoid Prop Drilling**: Use Context API or state management libraries for deeply nested state

### Examples:
```typescript
// ✅ Good: Grouped related state
const [assessmentData, setAssessmentData] = useState({
  skills: [] as string[],
  experience: "",
  interests: [] as string[],
  goals: ""
});

// ❌ Bad: Separate state for related data
const [skills, setSkills] = useState<string[]>([]);
const [experience, setExperience] = useState("");
const [interests, setInterests] = useState<string[]>([]);
const [goals, setGoals] = useState("");
```

## TypeScript Rules (CRITICAL)

**ALWAYS maintain strict type safety to prevent runtime errors and improve developer experience.**

### Type Safety Requirements:
* **No `any` Types**: Avoid using `any` type - use proper TypeScript interfaces instead
* **Strict Interfaces**: Define clear interfaces for all props, state, and API responses
* **Type Guards**: Use type guards for runtime type checking
* **Generic Types**: Use generics for reusable components and functions
* **Union Types**: Use union types for controlled values (e.g., `'loading' | 'success' | 'error'`)

### Interface Design:
* **Descriptive Names**: Use clear, descriptive names for interfaces (e.g., `ICareerNode`, `AssessmentData`)
* **Optional Properties**: Mark optional properties with `?` operator
* **Readonly Properties**: Use `readonly` for immutable data
* **Extend Interfaces**: Use interface extension for related types

### Examples:
```typescript
// ✅ Good: Proper interface definition
interface ICareerNode {
  id: string;
  title: string;
  level: 'entry' | 'mid' | 'senior' | 'executive';
  skills: string[];
  salary?: {
    min: number;
    max: number;
  };
}

// ❌ Bad: Using any type
const convertToCareerNode = (bookmark: any): ICareerNode => ({
  // This loses type safety
});
```

## Error Handling Rules (CRITICAL)

**ALWAYS implement comprehensive error handling to provide a robust user experience.**

### Error Handling Requirements:
* **Try-Catch Blocks**: Wrap all async operations in try-catch blocks
* **User-Friendly Messages**: Display clear, actionable error messages to users
* **Error Boundaries**: Use React Error Boundaries for component-level error handling
* **Fallback UI**: Provide fallback UI for error states
* **Error Logging**: Log errors for debugging while protecting user privacy
* **Retry Mechanisms**: Provide retry options for recoverable errors

### Error State Management:
* **Error State**: Always maintain error state in components
* **Error Clearing**: Clear errors when user takes corrective action
* **Loading States**: Show loading states during error recovery
* **Graceful Degradation**: App should continue functioning even with partial failures

### Examples:
```typescript
// ✅ Good: Comprehensive error handling
const [error, setError] = useState<string | null>(null);
const [loading, setLoading] = useState(false);

const handleAsyncOperation = async () => {
  setLoading(true);
  setError(null);
  try {
    const result = await someAsyncOperation();
    setData(result);
  } catch (err) {
    setError(err instanceof Error ? err.message : 'An error occurred');
  } finally {
    setLoading(false);
  }
};
```

## Performance Rules (CRITICAL)

**ALWAYS optimize for performance, especially on mobile devices with limited resources.**

### Performance Requirements:
* **React.memo**: Use React.memo for components that receive the same props frequently
* **useMemo**: Use useMemo for expensive calculations
* **useCallback**: Use useCallback for stable function references passed to child components
* **Code Splitting**: Use React.lazy and Suspense for route-based code splitting
* **Bundle Size**: Monitor and optimize bundle size regularly
* **Mobile Performance**: Optimize for mobile networks and devices

### Optimization Patterns:
* **Debouncing**: Debounce search inputs and API calls
* **Virtual Scrolling**: Use virtual scrolling for large lists
* **Image Optimization**: Use lazy loading and responsive images
* **Caching**: Implement proper caching strategies for API responses

### Examples:
```typescript
// ✅ Good: Optimized component
const SearchPage = React.memo(() => {
  const [searchQuery, setSearchQuery] = useState("");
  
  const debouncedSearch = useMemo(
    () => debounce((query: string) => {
      // Perform search
    }, 300),
    []
  );
  
  const handleSearch = useCallback((query: string) => {
    setSearchQuery(query);
    debouncedSearch(query);
  }, [debouncedSearch]);
  
  return <SearchInput value={searchQuery} onChange={handleSearch} />;
});
```

## Code Quality Rules (CRITICAL)

**ALWAYS maintain high code quality standards for long-term maintainability.**

### Code Quality Requirements:
* **Remove Debug Code**: Remove all console.log statements before production
* **Clean Up Comments**: Remove TODO, FIXME, and HACK comments or address them
* **Consistent Formatting**: Use consistent code formatting and indentation
* **Meaningful Names**: Use descriptive variable and function names
* **Single Responsibility**: Each function should do one thing well
* **DRY Principle**: Don't Repeat Yourself - extract common logic

### Code Review Checklist:
* **No Console Logs**: Remove all debugging console.log statements
* **Type Safety**: Ensure all code is properly typed
* **Error Handling**: Verify proper error handling is implemented
* **Performance**: Check for performance optimizations
* **Accessibility**: Ensure components are accessible
* **Mobile Optimization**: Verify mobile-friendly implementation

### Examples:
```typescript
// ❌ Bad: Debug code left in production
const handleSearch = () => {
  console.log('Searching for:', searchQuery); // Remove this
  // Search logic
};

// ✅ Good: Clean production code
const handleSearch = () => {
  // Search logic
};
```

## API Usage Rules

* **Never use deprecated React APIs**: Always check for and use the latest React patterns.
* **Replace deprecated methods immediately**: When React marks an API as obsolete, update all usages.
* **Use modern hooks**: Prefer hooks over class components and lifecycle methods.
* **Implement proper error handling**: Always handle API errors and loading states.
* **Check React documentation regularly**: Stay updated with the latest React patterns.
* **Test with latest React versions**: Ensure compatibility with current React releases.
* **Mobile API optimization**: Use mobile-optimized API calls with proper caching and offline support.

## Project Structure Guidelines

* **Modular Architecture**: Organize code into logical modules (components, hooks, utils, types, etc.).
* **Clear Separation of Concerns**: Each module should have a specific responsibility.
* **Scalable Design**: Structure should support project growth and feature additions.
* **Consistent Naming**: Use consistent naming conventions across the entire project.
* **Documentation**: Maintain up-to-date documentation for all major components and features.
* **Mobile-first structure**: Organize components with mobile considerations in mind.

## Version Control Best Practices

* **Meaningful Commits**: Write clear, descriptive commit messages.
* **Feature Branches**: Use feature branches for new development.
* **Code Review**: Review code before merging to main branch.
* **Asset Management**: Use .gitignore to exclude generated files and sensitive data.
* **Backup Strategy**: Regular backups of project files and assets.

## Testing and Quality Assurance

* **Unit Testing**: Write unit tests for critical business logic and utilities.
* **Component Testing**: Test React components using React Testing Library.
* **Integration Testing**: Test component interactions and data flow.
* **Performance Testing**: Monitor bundle size and component render performance.
* **Accessibility Testing**: Ensure components meet WCAG guidelines.
* **Cross-browser Testing**: Test on target browsers regularly.
* **Mobile Testing**: Test on Android devices and emulators to ensure mobile compatibility.

## Career Roadmap Specific Rules

* **Data Structure**: Use consistent interfaces for career nodes, paths, and categories as defined in `docs/DESIGN.md`.
* **Visualization**: Implement responsive and accessible career path visualizations following the design specifications.
* **User Experience**: Focus on intuitive navigation and clear information hierarchy as outlined in the design document.
* **Performance**: Optimize for large datasets of career information with proper caching and pagination.
* **Accessibility**: Ensure career roadmaps are accessible to users with disabilities (WCAG 2.1 AA compliance).
* **Internationalization**: Plan for multi-language support in career content.
* **Design Reference**: Always refer to `docs/DESIGN.md` for feature specifications, data models, and implementation guidelines.
* **Mobile Career Experience**: Design career roadmaps to be easily navigable on mobile devices with touch-friendly interactions.

## Build and Deployment Rules

* **Always Build and Run After Major Updates**: After implementing significant features, UI changes, or adding new pages/components, ALWAYS run the complete build and deployment process:
  1. `npm run build` - Build the web assets
  2. `npx cap sync` - Sync with Android project  
  3. `npx cap open android` - Open in Android Studio for testing
* **Android Testing**: Test all major changes on Android device/emulator to ensure mobile compatibility
* **Cross-Platform Validation**: Verify that web and mobile versions work consistently
* **Performance Monitoring**: Check bundle size and loading performance after major updates
* **Mobile Deployment**: Ensure the app is ready for Google Play Store deployment

## Key Conventions

1. Follow React's component-based architecture for modular and reusable UI elements.
2. Prioritize performance optimization and bundle size management in every stage of development.
3. Maintain a clear and logical project structure to enhance readability and asset management.
4. Use TypeScript for type safety and better developer experience.
5. Document all major components with JSDoc comments.
6. Use a phased data loading system for all async operations to prevent dependency issues.
7. Implement proper error handling and loading states in all components.
8. Always use the latest React patterns and avoid deprecated methods.
9. Ensure proper type safety when using external APIs and data.
10. Follow consistent naming conventions and coding standards throughout the project.
11. **ALWAYS build and run on Android after major updates** - This ensures mobile compatibility and catches platform-specific issues early.
12. **Design mobile-first** - All UI components must be optimized for Google/Android devices with touch-friendly interfaces.

Refer to React documentation, TypeScript guides, and modern web development best practices for optimal application architecture, component design, and performance optimization.
alwaysApply: true
---
